// Generated by CoffeeScript 1.6.3
(function() {
  var MIN_FIELD_SELECTION, STATUS, Schema, TicketSchema, mongoose, timestamps, _;

  mongoose = require("mongoose");

  Schema = mongoose.Schema;

  _ = require('underscore');

  timestamps = require("mongoose-times");

  STATUS = require("../enums/ticket_status");

  MIN_FIELD_SELECTION = {
    select: 'id'
  };

  TicketSchema = new Schema({
    title: String,
    owner_id: String,
    status: {
      type: String,
      "default": STATUS.PENDING
    },
    content: Schema.Types.Mixed,
    comments: [
      {
        name: String,
        kind: String,
        content: String,
        date: Date
      }
    ]
  });

  TicketSchema.plugin(timestamps, {
    created: "created_at",
    lastUpdated: "updated_at"
  });

  TicketSchema.path('title').validate(function(title) {
    return title.length;
  }, 'Title cannot be blank');

  TicketSchema.path('content').validate(function(content) {
    return content != null;
  }, 'content cannot be blank');

  TicketSchema.path('owner_id').validate(function(owner_id) {
    return owner_id.length;
  }, 'Owner id cannot be blank');

  TicketSchema.pre('save', function(next) {
    var query, theTitle;
    if (!this.isNew) {
      return next();
    }
    query = {
      $and: [
        {
          title: this.title
        }, {
          status: {
            $ne: [STATUS.COMPLETE, STATUS.ABANDON]
          }
        }
      ]
    };
    theTitle = this.title;
    mongoose.model('Ticket').findOne(query, 'title', function(err, ticket) {
      if (err != null) {
        return next(err);
      }
      if (ticket != null) {
        return next(new Error("ticket " + theTitle + " already exist"));
      }
      next();
    });
  });

  TicketSchema.statics.changeStatus = function(query, status, callback) {
    var where,
      _this = this;
    console.log("[ticket::changeStatus] ");
    if (!STATUS.isValid(status)) {
      return callback(new Error("invalid status:" + status));
    }
    where = [];
    if (query.title != null) {
      where.push({
        title: query.title
      });
    } else if (query.id != null) {
      where.push({
        id: query.id
      });
    } else {
      return callback(new Error("bad query, missing id neither title"));
    }
    switch (status) {
      case STATUS.COMPLETE:
        where.push({
          status: {
            $ne: STATUS.ABANDON
          }
        });
        break;
      case STATUS.ABANDON:
        where.push({
          status: {
            $ne: STATUS.COMPLETE
          }
        });
        break;
      case STATUS.PROCESSING:
        where.push({
          status: STATUS.PENDING
        });
    }
    this.findOneAndUpdate({
      $and: where
    }, {
      status: status
    }, MIN_FIELD_SELECTION, function(err, ticket) {
      console.log("[ticket] err:" + err + ", ticket:%j", ticket);
      if (err != null) {
        return callback(err);
      }
      if (ticket == null) {
        return callback(new Error("missing ticket for query: " + (JSON.stringify(query))));
      }
      _this.addComment(ticket.id, "system", "primary", "change ticket status to " + status, callback);
    });
  };

  TicketSchema.statics.addComment = function(id, name, kind, content, callback) {
    var update;
    console.log("[ticket::addComment]");
    if (!((id != null) && (name != null) && (kind != null) && (content != null) && (callback != null))) {
      return callback(new Error("missing arrgument. id:" + id + ", name:" + name + ", kind:" + kind + ", content:" + content + ", callback:" + callback));
    }
    update = {
      $push: {
        comments: {
          name: name,
          kind: kind,
          content: content,
          date: Date.now()
        }
      }
    };
    this.findByIdAndUpdate(id, update, callback);
  };

  mongoose.model('Ticket', TicketSchema);

}).call(this);
