// Generated by CoffeeScript 1.6.3
(function() {
  var STATUS, Schema, TicketSchema, mongoose, timestamps, _;

  mongoose = require("mongoose");

  Schema = mongoose.Schema;

  _ = require('underscore');

  timestamps = require("mongoose-times");

  STATUS = require("../enums/ticket_status");

  TicketSchema = new Schema({
    title: String,
    owner_id: String,
    status: {
      type: String,
      "default": STATUS.PENDING
    },
    content: Schema.Types.Mixed,
    comments: [
      {
        name: String,
        type: String,
        body: String,
        date: Date
      }
    ]
  });

  TicketSchema.plugin(timestamps, {
    created: "created_at",
    lastUpdated: "updated_at"
  });

  TicketSchema.path('title').validate(function(title) {
    return title.length;
  }, 'Title cannot be blank');

  TicketSchema.path('content').validate(function(content) {
    return content != null;
  }, 'content cannot be blank');

  TicketSchema.path('owner_id').validate(function(owner_id) {
    return owner_id.length;
  }, 'Owner id cannot be blank');

  TicketSchema.pre('save', function(next) {
    var query, theTitle;
    if (!this.isNew) {
      return next();
    }
    query = {
      $and: [
        {
          title: this.title
        }, {
          status: {
            $ne: [STATUS.COMPLETE, STATUS.ABANDON]
          }
        }
      ]
    };
    theTitle = this.title;
    mongoose.model('Ticket').findOne(query, 'title', function(err, ticket) {
      if (err != null) {
        return next(err);
      }
      if (ticket != null) {
        return next(new Error("ticket " + theTitle + " already exist"));
      }
      next();
    });
  });

  TicketSchema.methods = {
    complete: function(callback) {
      this.status = STATUS.COMPLETE;
      this.save(callback);
    },
    abandon: function(callback) {
      this.status = STATUS.ABANDON;
      this.save(callback);
    },
    appendLog: function(name, type, body, callback) {
      if (typeof log === "undefined" || log === null) {
        return callback("missing log content");
      }
      this.log.push({
        name: name,
        type: type,
        body: body,
        date: Date.now()
      });
      this.save(callback);
    }
  };

  TicketSchema.statics.changeStatus = function(query, status, callback) {
    var where;
    if (!STATUS.isValid(status)) {
      callback(new Error("invalid status:" + status));
    }
    where = [];
    if (query.title != null) {
      where.push({
        title: query.title
      });
    } else if (query.id != null) {
      where.push({
        id: query.id
      });
    } else {
      callback(new Error("bad query, missing id neither title"));
    }
    switch (status) {
      case STATUS.COMPLETE:
        where.push({
          status: {
            $ne: STATUS.ABANDON
          }
        });
        break;
      case STATUS.ABANDON:
        where.push({
          status: {
            $ne: STATUS.COMPLETE
          }
        });
        break;
      case STATUS.PROCESSING:
        where.push({
          status: STATUS.PENDING
        });
    }
    this.findOneAndUpdate({
      $and: where
    }, {
      status: status
    }, callback);
  };

  TicketSchema;

  mongoose.model('Ticket', TicketSchema);

}).call(this);
